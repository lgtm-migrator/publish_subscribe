{"version":3,"file":"publish_subscribe.cjs","sources":["../src/const/PROTOTYPE_ASYNC.mjs","../src/const/PROTOTYPE_SYNC.mjs","../src/core/Subscription.mjs","../src/utils/generateToken.mjs","../src/const/TOKEN_LENGTH.mjs","../src/utils/getPrototypeName.mjs","../src/utils/call.mjs","../src/utils/cloneDeep.mjs","../src/utils/clone.mjs","../src/utils/isPrimitive.mjs","../src/utils/objectKeys.mjs","../src/utils/isObjectEmpty.mjs","../src/utils/objectSize.mjs","../src/utils/isSame.mjs","../src/utils/newObject.mjs","../src/core/PublishSubscribe.mjs"],"sourcesContent":["export default \"[object AsyncFunction]\";\n","export default \"[object Function]\";\n","import generateToken from \"../utils/generateToken\";\n\nclass Subscription {\n  // callback;\n  // channel;\n  // once;\n  // token;\n  constructor(channel, callback, once = false) {\n    this.callback = callback;\n    this.channel = channel;\n    this.once = once;\n    this.token = generateToken();\n  }\n}\n\nexport default Subscription;\n","import TOKEN_LENGTH from \"../const/TOKEN_LENGTH\";\n\nexport default function generateToken() {\n  const random = new Array(TOKEN_LENGTH);\n  for (let index = 0; index < TOKEN_LENGTH; index += 1) {\n    random[index] = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"[Math.floor(Math.random() * 62)];\n  }\n  return random.join(\"\");\n}\n","export default 16;\n","export default function getPrototypeName(value) {\n  return Object.prototype.toString.call(value);\n}\n","import PROTOTYPE_ASYNC from \"../const/PROTOTYPE_ASYNC\";\nimport PROTOTYPE_SYNC from \"../const/PROTOTYPE_SYNC\";\nimport getPrototypeName from \"./getPrototypeName\";\n\nexport default function call(callback, args) {\n  if (!callback) {\n    return;\n  }\n  switch (getPrototypeName(callback)) {\n    case PROTOTYPE_ASYNC:\n      callback(...args)\n        .then(() => {})\n        .catch(() => {});\n      break;\n    case PROTOTYPE_SYNC:\n      try {\n        callback(...args);\n      } catch (_error) {\n        //\n      }\n      break;\n  }\n}\n","function clone(val) {\n  switch (typeOf(val)) {\n    case \"array\":\n      return val.slice();\n    case \"object\":\n      return Object.assign({}, val);\n    case \"date\":\n      return new val.constructor(Number(val));\n    case \"map\":\n      return new Map(val);\n    case \"set\":\n      return new Set(val);\n    case \"buffer\":\n      return cloneBuffer(val);\n    case \"symbol\":\n      return cloneSymbol(val);\n    case \"arraybuffer\":\n      return cloneArrayBuffer(val);\n    case \"float32array\":\n    case \"float64array\":\n    case \"int16array\":\n    case \"int32array\":\n    case \"int8array\":\n    case \"uint16array\":\n    case \"uint32array\":\n    case \"uint8clampedarray\":\n    case \"uint8array\":\n      return cloneTypedArray(val);\n    case \"regexp\":\n      return cloneRegExp(val);\n    case \"error\":\n      return Object.create(val);\n    default: {\n      return val;\n    }\n  }\n}\nfunction cloneRegExp(val) {\n  const flags = val.flags !== void 0 ? val.flags : /\\w+$/.exec(val) || void 0;\n  const re = new val.constructor(val.source, flags);\n  re.lastIndex = val.lastIndex;\n  return re;\n}\nfunction cloneArrayBuffer(val) {\n  const res = new val.constructor(val.byteLength);\n  new Uint8Array(res).set(new Uint8Array(val));\n  return res;\n}\nfunction cloneTypedArray(val) {\n  return new val.constructor(val.buffer, val.byteOffset, val.length);\n}\nfunction cloneBuffer(val) {\n  const len = val.length;\n  const buf = Buffer.allocUnsafe ? Buffer.allocUnsafe(len) : Buffer.from(len);\n  val.copy(buf);\n  return buf;\n}\nfunction cloneSymbol(val) {\n  return Symbol.prototype.valueOf ? Object(Symbol.prototype.valueOf.call(val)) : {};\n}\nfunction isBuffer(obj) {\n  return (\n    obj !== null &&\n    Boolean(obj.constructor) &&\n    typeof obj.constructor.isBuffer === \"function\" &&\n    obj.constructor.isBuffer(obj)\n  );\n}\nfunction typeOf(val) {\n  if (typeof val === \"undefined\") {\n    return \"undefined\";\n  }\n  if (val === null) {\n    return \"null\";\n  }\n  if (val === true || val === false || val instanceof Boolean) {\n    return \"boolean\";\n  }\n  if (typeof val === \"string\" || val instanceof String) {\n    return \"string\";\n  }\n  if (typeof val === \"number\" || val instanceof Number) {\n    return \"number\";\n  }\n  if (typeof val === \"function\" || val instanceof Function) {\n    return \"function\";\n  }\n  if (typeof Array.isArray !== \"undefined\" && Array.isArray(val)) {\n    return \"array\";\n  }\n  if (val instanceof RegExp) {\n    return \"regexp\";\n  }\n  if (val instanceof Date) {\n    return \"date\";\n  }\n  var type = toString.call(val);\n  if (type === \"[object RegExp]\") {\n    return \"regexp\";\n  }\n  if (type === \"[object Date]\") {\n    return \"date\";\n  }\n  if (type === \"[object Arguments]\") {\n    return \"arguments\";\n  }\n  if (type === \"[object Error]\") {\n    return \"error\";\n  }\n  if (isBuffer(val)) {\n    return \"buffer\";\n  }\n  if (type === \"[object Set]\") {\n    return \"set\";\n  }\n  if (type === \"[object WeakSet]\") {\n    return \"weakset\";\n  }\n  if (type === \"[object Map]\") {\n    return \"map\";\n  }\n  if (type === \"[object WeakMap]\") {\n    return \"weakmap\";\n  }\n  if (type === \"[object Symbol]\") {\n    return \"symbol\";\n  }\n  if (type === \"[object Int8Array]\") {\n    return \"int8array\";\n  }\n  if (type === \"[object Uint8Array]\") {\n    return \"uint8array\";\n  }\n  if (type === \"[object Uint8ClampedArray]\") {\n    return \"uint8clampedarray\";\n  }\n  if (type === \"[object Int16Array]\") {\n    return \"int16array\";\n  }\n  if (type === \"[object Uint16Array]\") {\n    return \"uint16array\";\n  }\n  if (type === \"[object Int32Array]\") {\n    return \"int32array\";\n  }\n  if (type === \"[object Uint32Array]\") {\n    return \"uint32array\";\n  }\n  if (type === \"[object Float32Array]\") {\n    return \"float32array\";\n  }\n  if (type === \"[object Float64Array]\") {\n    return \"float64array\";\n  }\n  return \"object\";\n}\nfunction isObject(obj) {\n  return typeof obj === \"object\" && obj !== null;\n}\nfunction isObjectObject(obj) {\n  return isObject(obj) === true && Object.prototype.toString.call(obj) === \"[object Object]\";\n}\nfunction isPlainObject(obj) {\n  let ctor;\n  let prototype;\n  if (isObjectObject(obj) === false) {\n    return false;\n  }\n  ctor = obj.constructor;\n  if (typeof ctor !== \"function\") {\n    return false;\n  }\n  prototype = ctor.prototype;\n  if (isObjectObject(prototype) === false) {\n    return false;\n  }\n  return prototype.hasOwnProperty(\"isPrototypeOf\") !== false;\n}\nfunction cloneDeep(val, instanceClone) {\n  switch (typeOf(val)) {\n    case \"object\":\n      return cloneObjectDeep(val, instanceClone);\n    case \"array\":\n      return cloneArrayDeep(val, instanceClone);\n    default: {\n      return clone(val);\n    }\n  }\n}\nfunction cloneObjectDeep(val, instanceClone) {\n  if (typeof instanceClone === \"function\") {\n    return instanceClone(val);\n  }\n  if (instanceClone || isPlainObject(val)) {\n    const res = new val.constructor();\n    for (let key in val) {\n      res[key] = cloneDeep(val[key], instanceClone);\n    }\n    return res;\n  }\n  return val;\n}\nfunction cloneArrayDeep(val, instanceClone) {\n  const res = new val.constructor(val.length);\n  for (let index = 0; index < val.length; index++) {\n    res[index] = cloneDeep(val[index], instanceClone);\n  }\n  return res;\n}\nexport default cloneDeep;\n","import cloneDeep from \"./cloneDeep\";\nimport isPrimitive from \"./isPrimitive\";\n\nexport default function clone(value) {\n  if (isPrimitive(value)) {\n    return value;\n  }\n  return cloneDeep(value);\n}\n","/**\n * @name isPrimitive\n * @description Return true on boolean, string, number, BigInt, null, Symbol and undefined\n * @param {*} value\n * @return {boolean}\n */\nexport default function isPrimitive(value) {\n  return Object(value) !== value;\n}\n","export default function objectKeys(object) {\n  return Object.keys(object);\n}\n","import objectSize from \"./objectSize\";\n\nexport default function isObjectEmpty(object) {\n  return objectSize(object) === 0;\n}\n","import objectKeys from \"./objectKeys\";\n\nexport default function objectSize(object) {\n  return objectKeys(object).length;\n}\n","export default function isSame(variable1, variable2) {\n  return Object.is(variable1, variable2);\n}\n","export default function newObject() {\n  return Object.create(null);\n}\n","import PROTOTYPE_ASYNC from \"../const/PROTOTYPE_ASYNC\";\nimport PROTOTYPE_SYNC from \"../const/PROTOTYPE_SYNC\";\nimport Subscription from \"../core/Subscription\";\nimport TOKEN_LENGTH from \"../const/TOKEN_LENGTH\";\nimport call from \"../utils/call\";\nimport clone from \"../utils/clone\";\nimport getPrototypeName from \"../utils/getPrototypeName\";\nimport isObjectEmpty from \"../utils/isObjectEmpty\";\nimport isSame from \"../utils/isSame\";\nimport newObject from \"../utils/newObject\";\nimport objectKeys from \"../utils/objectKeys\";\n\n/**\n * @class PublishSubscribe\n */\nclass PublishSubscribe {\n  // __channels = new Set();\n  // __createChannel;\n  // __createSubscription;\n  // __hasLogging;\n  // __isValidCallback;\n  // __isValidChannel;\n  // __isValidToken;\n  // __logging;\n  // __onPublish;\n  // __subscriptions = new Map();\n  /**\n   * @name constructor\n   * @public\n   * @constructor\n   */\n  constructor() {\n    this.__channels = new Set();\n    this.__onSubscribe = new Map();\n    this.__onPublish = () => {};\n    this.__subscriptions = new Map();\n    this.__isValidCallback = function isValidCallback(callback) {\n      if (!callback) {\n        return false;\n      }\n      return [PROTOTYPE_ASYNC, PROTOTYPE_SYNC].includes(getPrototypeName(callback));\n    }.bind(this);\n    this.__isValidChannel = function isValidChannel(channel) {\n      return (\n        typeof channel === \"string\" ||\n        typeof channel === \"symbol\" ||\n        (typeof channel === \"number\" && Number.isFinite(channel))\n      );\n    }.bind(this);\n    this.__isValidToken = function isValidToken(token) {\n      return typeof token === \"string\" && token.length === TOKEN_LENGTH;\n    }.bind(this);\n    this.__createChannel = function createChannel(channel) {\n      if (!this.hasChannel(channel)) {\n        this.__channels.add(channel);\n        this.__subscriptions.set(channel, newObject());\n      }\n    }.bind(this);\n    this.__createSubscription = function createSubscription(channel, callback, once) {\n      const subscription = new Subscription(channel, callback, once);\n      const subscriptionReference = this.__subscriptions.get(channel);\n      subscriptionReference[subscription.token] = subscription;\n      return subscription.token;\n    }.bind(this);\n    this.disableLogging();\n    this.dropAll();\n    this.onPublish();\n  }\n  /**\n   * @name disableLogging\n   * @public\n   * @returns {void}\n   */\n  disableLogging() {\n    this.__logging = () => {};\n    this.__hasLogging = false;\n  }\n  /**\n   * @name dropAll\n   * @public\n   * @returns {void}\n   */\n  dropAll() {\n    this.__logging(\"dropAll\");\n    this.__channels.clear();\n    this.__onSubscribe.clear();\n    this.__subscriptions.clear();\n  }\n  /**\n   * @name dropChannel\n   * @public\n   * @param {number|string|symbol} channel\n   * @returns {void}\n   */\n  dropChannel(channel) {\n    this.__logging(\"dropChannel\", { channel });\n    if (!this.hasChannel(channel)) {\n      return;\n    }\n    this.__channels.delete(channel);\n    this.__subscriptions.set(channel, newObject());\n  }\n  /**\n   * @name getCallback\n   * @description Get subscription callback by token\n   * @public\n   * @param {string} token\n   * @returns {void|Function}\n   */\n  getCallback(token) {\n    if (!this.__isValidToken(token)) {\n      return;\n    }\n    let callback = undefined;\n    Array.from(this.__subscriptions.values()).some((subscriptions) => {\n      if (!(token in subscriptions)) {\n        return false;\n      }\n      callback = subscriptions[token].callback;\n      return true;\n    });\n    return callback;\n  }\n  /**\n   * @name getChannels\n   * @public\n   * @returns {Array.<number|string>}\n   */\n  getChannels() {\n    return Array.from(this.__channels)\n      .filter((channel) => typeof channel !== \"symbol\")\n      .sort((alpha, beta) => alpha.localeCompare(beta));\n  }\n  /**\n   * @name hasChannel\n   * @public\n   * @param {number|string|symbol} channel\n   * @returns {boolean}\n   */\n  hasChannel(channel) {\n    return this.__channels.has(channel);\n  }\n  /**\n   * @name hasSubscription\n   * @public\n   * @param {number|string|symbol} channel\n   * @returns {boolean}\n   */\n  hasSubscription(channel) {\n    if (!this.hasChannel(channel)) {\n      return false;\n    }\n    if (!this.__subscriptions.has(channel)) {\n      return false;\n    }\n    return !isObjectEmpty(this.__subscriptions.get(channel));\n  }\n  /**\n   * @name onPublish\n   * @public\n   * @param {function=} callback\n   * @returns {void}\n   */\n  onPublish(callback = undefined) {\n    if (callback === undefined) {\n      this.__onPublish = () => {};\n      return;\n    }\n    if (!this.__isValidCallback(callback)) {\n      return;\n    }\n    this.__onPublish = (channel, data) => {\n      call(callback, [channel, data]);\n    };\n  }\n  /**\n   * @name onSubscribe\n   * @public\n   * @param {number|string|symbol} channel\n   * @param {*=} data\n   * @param {boolean=} cloneData\n   * @returns {void}\n   * @throws TypeError\n   */\n  onSubscribe(channel, data, cloneData = true) {\n    this.__logging(\"onSubscribe\", { channel, data });\n    if (!this.__isValidChannel(channel)) {\n      throw new TypeError(\"Channel name should be String, Symbol, Number.\");\n    }\n    this.__onSubscribe.set(channel, { cloneData, data });\n  }\n  /**\n   * @name onSubscribeClear\n   * @public\n   * @param {number|string|symbol} channel\n   * @returns {void}\n   * @throws TypeError\n   */\n  onSubscribeClear(channel) {\n    this.__logging(\"onSubscribeClear\", { channel });\n    if (!this.__isValidChannel(channel)) {\n      throw new TypeError(\"Channel name should be String, Symbol, Number.\");\n    }\n    this.__onSubscribe.delete(channel);\n  }\n  /**\n   * @name publish\n   * @public\n   * @param {number|string|symbol} channel\n   * @param {*=} data\n   * @param {boolean=} cloneData\n   * @param {boolean=} sticky\n   * @returns {void}\n   */\n  publish(channel, data, cloneData = true, sticky = false) {\n    let getData;\n    if (cloneData) {\n      getData = () => clone(data);\n    } else {\n      getData = () => data;\n    }\n    this.__logging(\"publish\", { channel, data: getData() });\n    this.__onPublish(channel, getData());\n    if (sticky) {\n      this.onSubscribe(channel, data, cloneData);\n    }\n    if (!this.hasChannel(channel)) {\n      return;\n    }\n    const promises = [];\n    const subscriptionReference = this.__subscriptions.get(channel);\n    objectKeys(subscriptionReference).forEach((token) => {\n      const subscription = subscriptionReference[token];\n      const callbackReference = subscription.callback;\n      switch (getPrototypeName(callbackReference)) {\n        case PROTOTYPE_ASYNC:\n          promises.push(\n            new Promise((resolve) => {\n              if (this.__hasLogging) {\n                this.__logging(\"publish -> send\", {\n                  channel,\n                  data: getData(),\n                  token,\n                });\n              }\n              let resultForPromise;\n              callbackReference(getData(), channel, token)\n                .then((promiseResult) => {\n                  resultForPromise = { channel, result: promiseResult, token };\n                  resolve(resultForPromise);\n                  if (this.__hasLogging) {\n                    this.__logging(\"publish -> receive\", {\n                      channel,\n                      result: clone(promiseResult),\n                      token,\n                    });\n                  }\n                  if (subscription.once) {\n                    delete subscriptionReference[token];\n                  }\n                })\n                .catch((error) => {\n                  resultForPromise = { channel, result: error, token };\n                  resolve(resultForPromise);\n                  if (this.__hasLogging) {\n                    this.__logging(\"publish -> receive\", {\n                      channel,\n                      result: error,\n                      token,\n                    });\n                  }\n                  if (subscription.once) {\n                    delete subscriptionReference[token];\n                  }\n                });\n            }),\n          );\n          break;\n        case PROTOTYPE_SYNC:\n          promises.push(\n            new Promise((resolve) => {\n              if (this.__hasLogging) {\n                this.__logging(\"publish -> send\", {\n                  channel,\n                  data: getData(),\n                  token,\n                });\n              }\n              let resultForPromise;\n              try {\n                resultForPromise = callbackReference(getData(), channel, token);\n              } catch (error) {\n                resultForPromise = error;\n              }\n              resolve({ channel, result: resultForPromise, token });\n              if (this.__hasLogging) {\n                this.__logging(\"publish -> receive\", {\n                  channel,\n                  result: clone(resultForPromise),\n                  token,\n                });\n              }\n              if (subscription.once) {\n                delete subscriptionReference[token];\n              }\n            }),\n          );\n          break;\n      }\n    });\n    Promise.all(promises).then(() => {});\n  }\n  /**\n   * @name publishAsync\n   * @public\n   * @param {number|string|symbol} channel\n   * @param {*=} data\n   * @param {boolean=} resultOnly\n   * @param {boolean=} cloneData\n   * @param {boolean=} sticky\n   * @returns {Promise}\n   */\n  publishAsync(channel, data, resultOnly = true, cloneData = true, sticky = false) {\n    let getData;\n    if (cloneData) {\n      getData = () => clone(data);\n    } else {\n      getData = () => data;\n    }\n    if (this.__hasLogging) {\n      this.__logging(\"publishAsync\", { channel, data: getData() });\n    }\n    this.__onPublish(channel, getData());\n    if (sticky) {\n      this.onSubscribe(channel, data, cloneData);\n    }\n    if (!this.hasChannel(channel)) {\n      return Promise.all([]);\n    }\n    const promises = [];\n    const subscriptionReference = this.__subscriptions.get(channel);\n    objectKeys(subscriptionReference).forEach((token) => {\n      const subscription = subscriptionReference[token];\n      const callbackReference = subscription.callback;\n      switch (getPrototypeName(callbackReference)) {\n        case PROTOTYPE_ASYNC:\n          promises.push(\n            new Promise((resolve) => {\n              if (this.__hasLogging) {\n                this.__logging(\"publishAsync -> send\", {\n                  channel,\n                  data: getData(),\n                  token,\n                });\n              }\n              let resultForPromise;\n              callbackReference(getData(), channel, token)\n                .then((promiseResult) => {\n                  resultForPromise = { channel, result: promiseResult, token };\n                  resolve(resultForPromise);\n                  if (this.__hasLogging) {\n                    this.__logging(\"publishAsync -> receive\", {\n                      channel,\n                      result: clone(promiseResult),\n                      token,\n                    });\n                  }\n                  if (subscription.once) {\n                    delete subscriptionReference[token];\n                  }\n                })\n                .catch((error) => {\n                  resultForPromise = { channel, result: error, token };\n                  resolve(resultForPromise);\n                  if (this.__hasLogging) {\n                    this.__logging(\"publishAsync -> receive\", {\n                      channel,\n                      result: error,\n                      token,\n                    });\n                  }\n                  if (subscription.once) {\n                    delete subscriptionReference[token];\n                  }\n                });\n            }),\n          );\n          break;\n        case PROTOTYPE_SYNC:\n          promises.push(\n            new Promise((resolve) => {\n              if (this.__hasLogging) {\n                this.__logging(\"publishAsync -> send\", {\n                  channel,\n                  data: getData(),\n                  token,\n                });\n              }\n              let resultForPromise;\n              try {\n                resultForPromise = callbackReference(getData(), channel, token);\n              } catch (error) {\n                resultForPromise = error;\n              }\n              resolve({ channel, result: resultForPromise, token });\n              if (this.__hasLogging) {\n                this.__logging(\"publishAsync -> receive\", {\n                  channel,\n                  result: clone(resultForPromise),\n                  token,\n                });\n              }\n              if (subscription.once) {\n                delete subscriptionReference[token];\n              }\n            }),\n          );\n          break;\n      }\n    });\n    if (resultOnly) {\n      return Promise.all(promises).then((results) => results.map((subscription) => subscription.result));\n    }\n    return Promise.all(promises);\n  }\n  /**\n   * @name publishSync\n   * @public\n   * @param {number|string|symbol} channel\n   * @param {*=} data\n   * @param {boolean=} resultOnly\n   * @param {boolean=} cloneData\n   * @param {function=} callback\n   * @param {boolean=} sticky\n   * @returns {array}\n   */\n  publishSync(channel, data, resultOnly = true, cloneData = true, callback = undefined, sticky = false) {\n    let getData;\n    if (cloneData) {\n      getData = () => clone(data);\n    } else {\n      getData = () => data;\n    }\n    if (this.__hasLogging) {\n      this.__logging(\"publishSync\", { channel, data: getData() });\n    }\n    this.__onPublish(channel, getData());\n    let curryCallback;\n    if (callback && this.__isValidCallback(callback)) {\n      curryCallback = (args) => call(callback, [args]);\n    } else {\n      curryCallback = () => {};\n    }\n    if (sticky) {\n      this.onSubscribe(channel, data, cloneData);\n    }\n    if (!this.hasChannel(channel)) {\n      curryCallback([]);\n      return [];\n    }\n    const subscriptionReference = this.__subscriptions.get(channel);\n    let results = [];\n    objectKeys(subscriptionReference).forEach((token) => {\n      const subscription = subscriptionReference[token];\n      const callbackReference = subscription.callback;\n      if (getPrototypeName(callbackReference) !== PROTOTYPE_SYNC) {\n        return;\n      }\n      if (this.__hasLogging) {\n        this.__logging(\"publishSync -> send\", {\n          channel,\n          data: getData(),\n          token,\n        });\n      }\n      let result;\n      try {\n        result = callbackReference(getData(), channel, token);\n      } catch (error) {\n        result = error;\n      }\n      results.push({ channel, result, token });\n      if (this.__hasLogging) {\n        this.__logging(\"publishSync -> receive\", {\n          channel,\n          result: clone(result),\n          token,\n        });\n      }\n      if (subscription.once) {\n        delete subscriptionReference[token];\n      }\n    });\n    if (resultOnly) {\n      results = results.map((subscription) => subscription.result);\n    }\n    curryCallback(results);\n    return results;\n  }\n  /**\n   * @name setLogging\n   * @public\n   * @param {function} callback\n   * @returns {void}\n   */\n  setLogging(callback) {\n    if (!this.__isValidCallback(callback)) {\n      return;\n    }\n    switch (getPrototypeName(callback)) {\n      case PROTOTYPE_ASYNC:\n        this.__logging = (method, info) => {\n          callback({ ...info, method })\n            .then(() => {})\n            .catch(() => {});\n        };\n        this.__hasLogging = true;\n        break;\n      case PROTOTYPE_SYNC:\n        this.__logging = (method, info) => {\n          try {\n            callback({ ...info, method });\n          } catch (_error) {\n            //\n          }\n        };\n        this.__hasLogging = true;\n        break;\n    }\n  }\n  /**\n   * @name subscribe\n   * @public\n   * @param {number|string|symbol} channel\n   * @param {function=} callback\n   * @param {boolean=} once\n   * @returns {TypeError|string}\n   * @throws TypeError\n   */\n  subscribe(channel, callback, once = false) {\n    this.__logging(\"subscribe\", { channel, callback, once });\n    if (!this.__isValidChannel(channel)) {\n      return new TypeError(\"Channel name should be String, Symbol, Number.\");\n    }\n    if (!this.__isValidCallback(callback)) {\n      return new TypeError(\"Callback should be a function.\");\n    }\n    this.__createChannel(channel);\n    const token = this.__createSubscription(channel, callback, once);\n    if (this.__onSubscribe.has(channel)) {\n      let { cloneData, data } = this.__onSubscribe.get(channel);\n      this.publish(channel, data, cloneData);\n    }\n    return token;\n  }\n  /**\n   * @name subscribeOnce\n   * @public\n   * @param {number|string|symbol} channel\n   * @param {function=} callback\n   * @returns {TypeError|string}\n   * @throws TypeError\n   */\n  subscribeOnce(channel, callback) {\n    this.__logging(\"subscribeOnce\", { channel, callback });\n    if (!this.__isValidChannel(channel)) {\n      return new TypeError(\"Channel name should be String, Symbol, Number.\");\n    }\n    if (!this.__isValidCallback(callback)) {\n      return new TypeError(\"Callback should be a function.\");\n    }\n    this.__createChannel(channel);\n    return this.__createSubscription(channel, callback);\n  }\n  /**\n   * @name unsubscribe\n   * @public\n   * @param {function|number|string|symbol} callbackChannelToken\n   * @param {function=} callback\n   * @returns {number}\n   */\n  unsubscribe(callbackChannelToken, callback) {\n    if (callback !== undefined) {\n      return this.unsubscribeByChannelAndCallback(callbackChannelToken, callback);\n    }\n    if (this.__isValidCallback(callbackChannelToken)) {\n      return this.unsubscribeByCallback(callbackChannelToken);\n    }\n    if (this.__isValidToken(callbackChannelToken)) {\n      return this.unsubscribeByToken(callbackChannelToken);\n    }\n    return 0;\n  }\n  /**\n   * @name unsubscribeByCallback\n   * @public\n   * @param {function} callback\n   * @returns {number}\n   */\n  unsubscribeByCallback(callback) {\n    this.__logging(\"unsubscribeByCallback\", { callback });\n    if (!this.__isValidCallback(callback)) {\n      return 0;\n    }\n    let deleted = 0;\n    this.__subscriptions.forEach((subscriptions) => {\n      objectKeys(subscriptions).forEach((key) => {\n        if (isSame(subscriptions[key].callback, callback)) {\n          delete subscriptions[key];\n          deleted += 1;\n        }\n      });\n    });\n    return deleted;\n  }\n  /**\n   * @name unsubscribeByChannelAndCallback\n   * @public\n   * @param {number|string|symbol} channel\n   * @param {function} callback\n   * @returns {number}\n   */\n  unsubscribeByChannelAndCallback(channel, callback) {\n    this.__logging(\"unsubscribeByChannelAndCallback\", { callback });\n    if (!this.hasSubscription(channel)) {\n      return 0;\n    }\n    const subscriptions = this.__subscriptions.get(channel);\n    let deleted = 0;\n    objectKeys(subscriptions).forEach((key) => {\n      if (isSame(subscriptions[key].callback, callback)) {\n        delete subscriptions[key];\n        deleted += 1;\n      }\n    });\n    return deleted;\n  }\n  /**\n   * @name unsubscribeByToken\n   * @public\n   * @param {string} token\n   * @returns {number}\n   */\n  unsubscribeByToken(token) {\n    this.__logging(\"unsubscribeByToken\", { token });\n    if (!this.__isValidToken(token)) {\n      return 0;\n    }\n    let deleted = 0;\n    this.__subscriptions.forEach((subscriptions) => {\n      if (token in subscriptions) {\n        delete subscriptions[token];\n        deleted += 1;\n      }\n    });\n    return deleted;\n  }\n}\n\nexport default PublishSubscribe;\n"],"names":["Subscription","constructor","channel","callback","once","token","generateToken","random","Array","index","Math","floor","join","getPrototypeName","value","Object","prototype","toString","call","args","PROTOTYPE_ASYNC","then","catch","PROTOTYPE_SYNC","_error","clone","val","typeOf","slice","assign","Number","Map","Set","cloneBuffer","len","length","buf","Buffer","allocUnsafe","from","copy","cloneSymbol","Symbol","valueOf","cloneArrayBuffer","res","byteLength","Uint8Array","set","cloneTypedArray","buffer","byteOffset","cloneRegExp","flags","exec","re","source","lastIndex","create","Boolean","String","Function","isArray","RegExp","Date","type","isBuffer","obj","isObjectObject","isObject","cloneDeep","instanceClone","cloneObjectDeep","isPlainObject","ctor","hasOwnProperty","key","cloneArrayDeep","isPrimitive","objectKeys","object","keys","isObjectEmpty","objectSize","isSame","variable1","variable2","is","newObject","PublishSubscribe","__channels","__onSubscribe","__onPublish","__subscriptions","__isValidCallback","isValidCallback","includes","bind","this","__isValidChannel","isValidChannel","isFinite","__isValidToken","isValidToken","__createChannel","createChannel","hasChannel","add","__createSubscription","createSubscription","subscription","get","disableLogging","dropAll","onPublish","__logging","__hasLogging","clear","dropChannel","delete","getCallback","undefined","values","some","subscriptions","getChannels","filter","sort","alpha","beta","localeCompare","has","hasSubscription","data","onSubscribe","cloneData","TypeError","onSubscribeClear","publish","sticky","getData","promises","subscriptionReference","forEach","callbackReference","push","Promise","resolve","resultForPromise","promiseResult","result","error","all","publishAsync","resultOnly","results","map","publishSync","curryCallback","setLogging","method","info","subscribe","subscribeOnce","unsubscribe","callbackChannelToken","unsubscribeByChannelAndCallback","unsubscribeByCallback","unsubscribeByToken","deleted"],"mappings":"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"}