{"version":3,"file":"publish_subscribe.min.js","sources":["../src/const/PROTOTYPE_ASYNC.mjs","../src/const/PROTOTYPE_SYNC.mjs","../src/core/Subscription.mjs","../src/utils/generateToken.mjs","../src/const/TOKEN_LENGTH.mjs","../src/utils/getPrototypeName.mjs","../src/utils/call.mjs","../src/utils/cloneDeep.mjs","../src/utils/clone.mjs","../src/utils/isPrimitive.mjs","../src/utils/objectKeys.mjs","../src/utils/isObjectEmpty.mjs","../src/utils/objectSize.mjs","../src/utils/isSame.mjs","../src/utils/newObject.mjs","../src/core/PublishSubscribe.mjs"],"sourcesContent":["export default \"[object AsyncFunction]\";\n","export default \"[object Function]\";\n","import generateToken from \"../utils/generateToken\";\n\nclass Subscription {\n  // callback;\n  // channel;\n  // once;\n  // token;\n  constructor(channel, callback, once = false) {\n    this.callback = callback;\n    this.channel = channel;\n    this.once = once;\n    this.token = generateToken();\n  }\n}\n\nexport default Subscription;\n","import TOKEN_LENGTH from \"../const/TOKEN_LENGTH\";\n\nexport default function generateToken() {\n  const random = new Array(TOKEN_LENGTH);\n  for (let index = 0; index < TOKEN_LENGTH; index += 1) {\n    random[index] = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"[Math.floor(Math.random() * 62)];\n  }\n  return random.join(\"\");\n}\n","export default 16;\n","export default function getPrototypeName(value) {\n  return Object.prototype.toString.call(value);\n}\n","import PROTOTYPE_ASYNC from \"../const/PROTOTYPE_ASYNC\";\nimport PROTOTYPE_SYNC from \"../const/PROTOTYPE_SYNC\";\nimport getPrototypeName from \"./getPrototypeName\";\n\nexport default function call(callback, args) {\n  if (!callback) {\n    return;\n  }\n  switch (getPrototypeName(callback)) {\n    case PROTOTYPE_ASYNC:\n      callback(...args)\n        .then(() => {})\n        .catch(() => {});\n      break;\n    case PROTOTYPE_SYNC:\n      try {\n        callback(...args);\n      } catch (_error) {\n        //\n      }\n      break;\n  }\n}\n","function clone(val) {\n  switch (typeOf(val)) {\n    case \"array\":\n      return val.slice();\n    case \"object\":\n      return Object.assign({}, val);\n    case \"date\":\n      return new val.constructor(Number(val));\n    case \"map\":\n      return new Map(val);\n    case \"set\":\n      return new Set(val);\n    case \"buffer\":\n      return cloneBuffer(val);\n    case \"symbol\":\n      return cloneSymbol(val);\n    case \"arraybuffer\":\n      return cloneArrayBuffer(val);\n    case \"float32array\":\n    case \"float64array\":\n    case \"int16array\":\n    case \"int32array\":\n    case \"int8array\":\n    case \"uint16array\":\n    case \"uint32array\":\n    case \"uint8clampedarray\":\n    case \"uint8array\":\n      return cloneTypedArray(val);\n    case \"regexp\":\n      return cloneRegExp(val);\n    case \"error\":\n      return Object.create(val);\n    default: {\n      return val;\n    }\n  }\n}\nfunction cloneRegExp(val) {\n  const flags = val.flags !== void 0 ? val.flags : /\\w+$/.exec(val) || void 0;\n  const re = new val.constructor(val.source, flags);\n  re.lastIndex = val.lastIndex;\n  return re;\n}\nfunction cloneArrayBuffer(val) {\n  const res = new val.constructor(val.byteLength);\n  new Uint8Array(res).set(new Uint8Array(val));\n  return res;\n}\nfunction cloneTypedArray(val) {\n  return new val.constructor(val.buffer, val.byteOffset, val.length);\n}\nfunction cloneBuffer(val) {\n  const len = val.length;\n  const buf = Buffer.allocUnsafe ? Buffer.allocUnsafe(len) : Buffer.from(len);\n  val.copy(buf);\n  return buf;\n}\nfunction cloneSymbol(val) {\n  return Symbol.prototype.valueOf ? Object(Symbol.prototype.valueOf.call(val)) : {};\n}\nfunction isBuffer(obj) {\n  return (\n    obj !== null &&\n    Boolean(obj.constructor) &&\n    typeof obj.constructor.isBuffer === \"function\" &&\n    obj.constructor.isBuffer(obj)\n  );\n}\nfunction typeOf(val) {\n  if (typeof val === \"undefined\") {\n    return \"undefined\";\n  }\n  if (val === null) {\n    return \"null\";\n  }\n  if (val === true || val === false || val instanceof Boolean) {\n    return \"boolean\";\n  }\n  if (typeof val === \"string\" || val instanceof String) {\n    return \"string\";\n  }\n  if (typeof val === \"number\" || val instanceof Number) {\n    return \"number\";\n  }\n  if (typeof val === \"function\" || val instanceof Function) {\n    return \"function\";\n  }\n  if (typeof Array.isArray !== \"undefined\" && Array.isArray(val)) {\n    return \"array\";\n  }\n  if (val instanceof RegExp) {\n    return \"regexp\";\n  }\n  if (val instanceof Date) {\n    return \"date\";\n  }\n  var type = toString.call(val);\n  if (type === \"[object RegExp]\") {\n    return \"regexp\";\n  }\n  if (type === \"[object Date]\") {\n    return \"date\";\n  }\n  if (type === \"[object Arguments]\") {\n    return \"arguments\";\n  }\n  if (type === \"[object Error]\") {\n    return \"error\";\n  }\n  if (isBuffer(val)) {\n    return \"buffer\";\n  }\n  if (type === \"[object Set]\") {\n    return \"set\";\n  }\n  if (type === \"[object WeakSet]\") {\n    return \"weakset\";\n  }\n  if (type === \"[object Map]\") {\n    return \"map\";\n  }\n  if (type === \"[object WeakMap]\") {\n    return \"weakmap\";\n  }\n  if (type === \"[object Symbol]\") {\n    return \"symbol\";\n  }\n  if (type === \"[object Int8Array]\") {\n    return \"int8array\";\n  }\n  if (type === \"[object Uint8Array]\") {\n    return \"uint8array\";\n  }\n  if (type === \"[object Uint8ClampedArray]\") {\n    return \"uint8clampedarray\";\n  }\n  if (type === \"[object Int16Array]\") {\n    return \"int16array\";\n  }\n  if (type === \"[object Uint16Array]\") {\n    return \"uint16array\";\n  }\n  if (type === \"[object Int32Array]\") {\n    return \"int32array\";\n  }\n  if (type === \"[object Uint32Array]\") {\n    return \"uint32array\";\n  }\n  if (type === \"[object Float32Array]\") {\n    return \"float32array\";\n  }\n  if (type === \"[object Float64Array]\") {\n    return \"float64array\";\n  }\n  return \"object\";\n}\nfunction isObject(obj) {\n  return typeof obj === \"object\" && obj !== null;\n}\nfunction isObjectObject(obj) {\n  return isObject(obj) === true && Object.prototype.toString.call(obj) === \"[object Object]\";\n}\nfunction isPlainObject(obj) {\n  let ctor;\n  let prototype;\n  if (isObjectObject(obj) === false) {\n    return false;\n  }\n  ctor = obj.constructor;\n  if (typeof ctor !== \"function\") {\n    return false;\n  }\n  prototype = ctor.prototype;\n  if (isObjectObject(prototype) === false) {\n    return false;\n  }\n  return prototype.hasOwnProperty(\"isPrototypeOf\") !== false;\n}\nfunction cloneDeep(val, instanceClone) {\n  switch (typeOf(val)) {\n    case \"object\":\n      return cloneObjectDeep(val, instanceClone);\n    case \"array\":\n      return cloneArrayDeep(val, instanceClone);\n    default: {\n      return clone(val);\n    }\n  }\n}\nfunction cloneObjectDeep(val, instanceClone) {\n  if (typeof instanceClone === \"function\") {\n    return instanceClone(val);\n  }\n  if (instanceClone || isPlainObject(val)) {\n    const res = new val.constructor();\n    for (let key in val) {\n      res[key] = cloneDeep(val[key], instanceClone);\n    }\n    return res;\n  }\n  return val;\n}\nfunction cloneArrayDeep(val, instanceClone) {\n  const res = new val.constructor(val.length);\n  for (let index = 0; index < val.length; index++) {\n    res[index] = cloneDeep(val[index], instanceClone);\n  }\n  return res;\n}\nexport default cloneDeep;\n","import cloneDeep from \"./cloneDeep\";\nimport isPrimitive from \"./isPrimitive\";\n\nexport default function clone(value) {\n  if (isPrimitive(value)) {\n    return value;\n  }\n  return cloneDeep(value);\n}\n","/**\n * @name isPrimitive\n * @description Return true on boolean, string, number, BigInt, null, Symbol and undefined\n * @param {*} value\n * @return {boolean}\n */\nexport default function isPrimitive(value) {\n  return Object(value) !== value;\n}\n","export default function objectKeys(object) {\n  return Object.keys(object);\n}\n","import objectSize from \"./objectSize\";\n\nexport default function isObjectEmpty(object) {\n  return objectSize(object) === 0;\n}\n","import objectKeys from \"./objectKeys\";\n\nexport default function objectSize(object) {\n  return objectKeys(object).length;\n}\n","export default function isSame(variable1, variable2) {\n  return Object.is(variable1, variable2);\n}\n","export default function newObject() {\n  return Object.create(null);\n}\n","import PROTOTYPE_ASYNC from \"../const/PROTOTYPE_ASYNC\";\nimport PROTOTYPE_SYNC from \"../const/PROTOTYPE_SYNC\";\nimport Subscription from \"../core/Subscription\";\nimport TOKEN_LENGTH from \"../const/TOKEN_LENGTH\";\nimport call from \"../utils/call\";\nimport clone from \"../utils/clone\";\nimport getPrototypeName from \"../utils/getPrototypeName\";\nimport isObjectEmpty from \"../utils/isObjectEmpty\";\nimport isSame from \"../utils/isSame\";\nimport newObject from \"../utils/newObject\";\nimport objectKeys from \"../utils/objectKeys\";\n\n/**\n * @class PublishSubscribe\n */\nclass PublishSubscribe {\n  // __channels = new Set();\n  // __createChannel;\n  // __createSubscription;\n  // __hasLogging;\n  // __isValidCallback;\n  // __isValidChannel;\n  // __isValidToken;\n  // __logging;\n  // __onPublish;\n  // __subscriptions = new Map();\n  /**\n   * @name constructor\n   * @public\n   * @constructor\n   */\n  constructor() {\n    this.__channels = new Set();\n    this.__onSubscribe = new Map();\n    this.__onPublish = () => {};\n    this.__subscriptions = new Map();\n    this.__isValidCallback = function isValidCallback(callback) {\n      if (!callback) {\n        return false;\n      }\n      return [PROTOTYPE_ASYNC, PROTOTYPE_SYNC].includes(getPrototypeName(callback));\n    }.bind(this);\n    this.__isValidChannel = function isValidChannel(channel) {\n      return (\n        typeof channel === \"string\" ||\n        typeof channel === \"symbol\" ||\n        (typeof channel === \"number\" && Number.isFinite(channel))\n      );\n    }.bind(this);\n    this.__isValidToken = function isValidToken(token) {\n      return typeof token === \"string\" && token.length === TOKEN_LENGTH;\n    }.bind(this);\n    this.__createChannel = function createChannel(channel) {\n      if (!this.hasChannel(channel)) {\n        this.__channels.add(channel);\n        this.__subscriptions.set(channel, newObject());\n      }\n    }.bind(this);\n    this.__createSubscription = function createSubscription(channel, callback, once) {\n      const subscription = new Subscription(channel, callback, once);\n      const subscriptionReference = this.__subscriptions.get(channel);\n      subscriptionReference[subscription.token] = subscription;\n      return subscription.token;\n    }.bind(this);\n    this.disableLogging();\n    this.dropAll();\n    this.onPublish();\n  }\n  /**\n   * @name disableLogging\n   * @public\n   * @returns {void}\n   */\n  disableLogging() {\n    this.__logging = () => {};\n    this.__hasLogging = false;\n  }\n  /**\n   * @name dropAll\n   * @public\n   * @returns {void}\n   */\n  dropAll() {\n    this.__logging(\"dropAll\");\n    this.__channels.clear();\n    this.__onSubscribe.clear();\n    this.__subscriptions.clear();\n  }\n  /**\n   * @name dropChannel\n   * @public\n   * @param {number|string|symbol} channel\n   * @returns {void}\n   */\n  dropChannel(channel) {\n    this.__logging(\"dropChannel\", { channel });\n    if (!this.hasChannel(channel)) {\n      return;\n    }\n    this.__channels.delete(channel);\n    this.__subscriptions.set(channel, newObject());\n  }\n  /**\n   * @name getCallback\n   * @description Get subscription callback by token\n   * @public\n   * @param {string} token\n   * @returns {void|Function}\n   */\n  getCallback(token) {\n    if (!this.__isValidToken(token)) {\n      return;\n    }\n    let callback = undefined;\n    Array.from(this.__subscriptions.values()).some((subscriptions) => {\n      if (!(token in subscriptions)) {\n        return false;\n      }\n      callback = subscriptions[token].callback;\n      return true;\n    });\n    return callback;\n  }\n  /**\n   * @name getChannels\n   * @public\n   * @returns {Array.<number|string>}\n   */\n  getChannels() {\n    return Array.from(this.__channels)\n      .filter((channel) => typeof channel !== \"symbol\")\n      .sort((alpha, beta) => alpha.localeCompare(beta));\n  }\n  /**\n   * @name hasChannel\n   * @public\n   * @param {number|string|symbol} channel\n   * @returns {boolean}\n   */\n  hasChannel(channel) {\n    return this.__channels.has(channel);\n  }\n  /**\n   * @name hasSubscription\n   * @public\n   * @param {number|string|symbol} channel\n   * @returns {boolean}\n   */\n  hasSubscription(channel) {\n    if (!this.hasChannel(channel)) {\n      return false;\n    }\n    if (!this.__subscriptions.has(channel)) {\n      return false;\n    }\n    return !isObjectEmpty(this.__subscriptions.get(channel));\n  }\n  /**\n   * @name onPublish\n   * @public\n   * @param {function=} callback\n   * @returns {void}\n   */\n  onPublish(callback = undefined) {\n    if (callback === undefined) {\n      this.__onPublish = () => {};\n      return;\n    }\n    if (!this.__isValidCallback(callback)) {\n      return;\n    }\n    this.__onPublish = (channel, data) => {\n      call(callback, [channel, data]);\n    };\n  }\n  /**\n   * @name onSubscribe\n   * @public\n   * @param {number|string|symbol} channel\n   * @param {*=} data\n   * @param {boolean=} cloneData\n   * @returns {void}\n   * @throws TypeError\n   */\n  onSubscribe(channel, data, cloneData = true) {\n    this.__logging(\"onSubscribe\", { channel, data });\n    if (!this.__isValidChannel(channel)) {\n      throw new TypeError(\"Channel name should be String, Symbol, Number.\");\n    }\n    this.__onSubscribe.set(channel, { cloneData, data });\n  }\n  /**\n   * @name onSubscribeClear\n   * @public\n   * @param {number|string|symbol} channel\n   * @returns {void}\n   * @throws TypeError\n   */\n  onSubscribeClear(channel) {\n    this.__logging(\"onSubscribeClear\", { channel });\n    if (!this.__isValidChannel(channel)) {\n      throw new TypeError(\"Channel name should be String, Symbol, Number.\");\n    }\n    this.__onSubscribe.delete(channel);\n  }\n  /**\n   * @name publish\n   * @public\n   * @param {number|string|symbol} channel\n   * @param {*=} data\n   * @param {boolean=} cloneData\n   * @param {boolean=} sticky\n   * @returns {void}\n   */\n  publish(channel, data, cloneData = true, sticky = false) {\n    let getData;\n    if (cloneData) {\n      getData = () => clone(data);\n    } else {\n      getData = () => data;\n    }\n    this.__logging(\"publish\", { channel, data: getData() });\n    this.__onPublish(channel, getData());\n    if (sticky) {\n      this.onSubscribe(channel, data, cloneData);\n    }\n    if (!this.hasChannel(channel)) {\n      return;\n    }\n    const promises = [];\n    const subscriptionReference = this.__subscriptions.get(channel);\n    objectKeys(subscriptionReference).forEach((token) => {\n      const subscription = subscriptionReference[token];\n      const callbackReference = subscription.callback;\n      switch (getPrototypeName(callbackReference)) {\n        case PROTOTYPE_ASYNC:\n          promises.push(\n            new Promise((resolve) => {\n              if (this.__hasLogging) {\n                this.__logging(\"publish -> send\", {\n                  channel,\n                  data: getData(),\n                  token,\n                });\n              }\n              let resultForPromise;\n              callbackReference(getData(), channel, token)\n                .then((promiseResult) => {\n                  resultForPromise = { channel, result: promiseResult, token };\n                  resolve(resultForPromise);\n                  if (this.__hasLogging) {\n                    this.__logging(\"publish -> receive\", {\n                      channel,\n                      result: clone(promiseResult),\n                      token,\n                    });\n                  }\n                  if (subscription.once) {\n                    delete subscriptionReference[token];\n                  }\n                })\n                .catch((error) => {\n                  resultForPromise = { channel, result: error, token };\n                  resolve(resultForPromise);\n                  if (this.__hasLogging) {\n                    this.__logging(\"publish -> receive\", {\n                      channel,\n                      result: error,\n                      token,\n                    });\n                  }\n                  if (subscription.once) {\n                    delete subscriptionReference[token];\n                  }\n                });\n            }),\n          );\n          break;\n        case PROTOTYPE_SYNC:\n          promises.push(\n            new Promise((resolve) => {\n              if (this.__hasLogging) {\n                this.__logging(\"publish -> send\", {\n                  channel,\n                  data: getData(),\n                  token,\n                });\n              }\n              let resultForPromise;\n              try {\n                resultForPromise = callbackReference(getData(), channel, token);\n              } catch (error) {\n                resultForPromise = error;\n              }\n              resolve({ channel, result: resultForPromise, token });\n              if (this.__hasLogging) {\n                this.__logging(\"publish -> receive\", {\n                  channel,\n                  result: clone(resultForPromise),\n                  token,\n                });\n              }\n              if (subscription.once) {\n                delete subscriptionReference[token];\n              }\n            }),\n          );\n          break;\n      }\n    });\n    Promise.all(promises).then(() => {});\n  }\n  /**\n   * @name publishAsync\n   * @public\n   * @param {number|string|symbol} channel\n   * @param {*=} data\n   * @param {boolean=} resultOnly\n   * @param {boolean=} cloneData\n   * @param {boolean=} sticky\n   * @returns {Promise}\n   */\n  publishAsync(channel, data, resultOnly = true, cloneData = true, sticky = false) {\n    let getData;\n    if (cloneData) {\n      getData = () => clone(data);\n    } else {\n      getData = () => data;\n    }\n    if (this.__hasLogging) {\n      this.__logging(\"publishAsync\", { channel, data: getData() });\n    }\n    this.__onPublish(channel, getData());\n    if (sticky) {\n      this.onSubscribe(channel, data, cloneData);\n    }\n    if (!this.hasChannel(channel)) {\n      return Promise.all([]);\n    }\n    const promises = [];\n    const subscriptionReference = this.__subscriptions.get(channel);\n    objectKeys(subscriptionReference).forEach((token) => {\n      const subscription = subscriptionReference[token];\n      const callbackReference = subscription.callback;\n      switch (getPrototypeName(callbackReference)) {\n        case PROTOTYPE_ASYNC:\n          promises.push(\n            new Promise((resolve) => {\n              if (this.__hasLogging) {\n                this.__logging(\"publishAsync -> send\", {\n                  channel,\n                  data: getData(),\n                  token,\n                });\n              }\n              let resultForPromise;\n              callbackReference(getData(), channel, token)\n                .then((promiseResult) => {\n                  resultForPromise = { channel, result: promiseResult, token };\n                  resolve(resultForPromise);\n                  if (this.__hasLogging) {\n                    this.__logging(\"publishAsync -> receive\", {\n                      channel,\n                      result: clone(promiseResult),\n                      token,\n                    });\n                  }\n                  if (subscription.once) {\n                    delete subscriptionReference[token];\n                  }\n                })\n                .catch((error) => {\n                  resultForPromise = { channel, result: error, token };\n                  resolve(resultForPromise);\n                  if (this.__hasLogging) {\n                    this.__logging(\"publishAsync -> receive\", {\n                      channel,\n                      result: error,\n                      token,\n                    });\n                  }\n                  if (subscription.once) {\n                    delete subscriptionReference[token];\n                  }\n                });\n            }),\n          );\n          break;\n        case PROTOTYPE_SYNC:\n          promises.push(\n            new Promise((resolve) => {\n              if (this.__hasLogging) {\n                this.__logging(\"publishAsync -> send\", {\n                  channel,\n                  data: getData(),\n                  token,\n                });\n              }\n              let resultForPromise;\n              try {\n                resultForPromise = callbackReference(getData(), channel, token);\n              } catch (error) {\n                resultForPromise = error;\n              }\n              resolve({ channel, result: resultForPromise, token });\n              if (this.__hasLogging) {\n                this.__logging(\"publishAsync -> receive\", {\n                  channel,\n                  result: clone(resultForPromise),\n                  token,\n                });\n              }\n              if (subscription.once) {\n                delete subscriptionReference[token];\n              }\n            }),\n          );\n          break;\n      }\n    });\n    if (resultOnly) {\n      return Promise.all(promises).then((results) => results.map((subscription) => subscription.result));\n    }\n    return Promise.all(promises);\n  }\n  /**\n   * @name publishSync\n   * @public\n   * @param {number|string|symbol} channel\n   * @param {*=} data\n   * @param {boolean=} resultOnly\n   * @param {boolean=} cloneData\n   * @param {function=} callback\n   * @param {boolean=} sticky\n   * @returns {array}\n   */\n  publishSync(channel, data, resultOnly = true, cloneData = true, callback = undefined, sticky = false) {\n    let getData;\n    if (cloneData) {\n      getData = () => clone(data);\n    } else {\n      getData = () => data;\n    }\n    if (this.__hasLogging) {\n      this.__logging(\"publishSync\", { channel, data: getData() });\n    }\n    this.__onPublish(channel, getData());\n    let curryCallback;\n    if (callback && this.__isValidCallback(callback)) {\n      curryCallback = (args) => call(callback, [args]);\n    } else {\n      curryCallback = () => {};\n    }\n    if (sticky) {\n      this.onSubscribe(channel, data, cloneData);\n    }\n    if (!this.hasChannel(channel)) {\n      curryCallback([]);\n      return [];\n    }\n    const subscriptionReference = this.__subscriptions.get(channel);\n    let results = [];\n    objectKeys(subscriptionReference).forEach((token) => {\n      const subscription = subscriptionReference[token];\n      const callbackReference = subscription.callback;\n      if (getPrototypeName(callbackReference) !== PROTOTYPE_SYNC) {\n        return;\n      }\n      if (this.__hasLogging) {\n        this.__logging(\"publishSync -> send\", {\n          channel,\n          data: getData(),\n          token,\n        });\n      }\n      let result;\n      try {\n        result = callbackReference(getData(), channel, token);\n      } catch (error) {\n        result = error;\n      }\n      results.push({ channel, result, token });\n      if (this.__hasLogging) {\n        this.__logging(\"publishSync -> receive\", {\n          channel,\n          result: clone(result),\n          token,\n        });\n      }\n      if (subscription.once) {\n        delete subscriptionReference[token];\n      }\n    });\n    if (resultOnly) {\n      results = results.map((subscription) => subscription.result);\n    }\n    curryCallback(results);\n    return results;\n  }\n  /**\n   * @name setLogging\n   * @public\n   * @param {function} callback\n   * @returns {void}\n   */\n  setLogging(callback) {\n    if (!this.__isValidCallback(callback)) {\n      return;\n    }\n    switch (getPrototypeName(callback)) {\n      case PROTOTYPE_ASYNC:\n        this.__logging = (method, info) => {\n          callback({ ...info, method })\n            .then(() => {})\n            .catch(() => {});\n        };\n        this.__hasLogging = true;\n        break;\n      case PROTOTYPE_SYNC:\n        this.__logging = (method, info) => {\n          try {\n            callback({ ...info, method });\n          } catch (_error) {\n            //\n          }\n        };\n        this.__hasLogging = true;\n        break;\n    }\n  }\n  /**\n   * @name subscribe\n   * @public\n   * @param {number|string|symbol} channel\n   * @param {function=} callback\n   * @param {boolean=} once\n   * @returns {TypeError|string}\n   * @throws TypeError\n   */\n  subscribe(channel, callback, once = false) {\n    this.__logging(\"subscribe\", { channel, callback, once });\n    if (!this.__isValidChannel(channel)) {\n      return new TypeError(\"Channel name should be String, Symbol, Number.\");\n    }\n    if (!this.__isValidCallback(callback)) {\n      return new TypeError(\"Callback should be a function.\");\n    }\n    this.__createChannel(channel);\n    const token = this.__createSubscription(channel, callback, once);\n    if (this.__onSubscribe.has(channel)) {\n      let { cloneData, data } = this.__onSubscribe.get(channel);\n      this.publish(channel, data, cloneData);\n    }\n    return token;\n  }\n  /**\n   * @name subscribeOnce\n   * @public\n   * @param {number|string|symbol} channel\n   * @param {function=} callback\n   * @returns {TypeError|string}\n   * @throws TypeError\n   */\n  subscribeOnce(channel, callback) {\n    this.__logging(\"subscribeOnce\", { channel, callback });\n    if (!this.__isValidChannel(channel)) {\n      return new TypeError(\"Channel name should be String, Symbol, Number.\");\n    }\n    if (!this.__isValidCallback(callback)) {\n      return new TypeError(\"Callback should be a function.\");\n    }\n    this.__createChannel(channel);\n    return this.__createSubscription(channel, callback);\n  }\n  /**\n   * @name unsubscribe\n   * @public\n   * @param {function|number|string|symbol} callbackChannelToken\n   * @param {function=} callback\n   * @returns {number}\n   */\n  unsubscribe(callbackChannelToken, callback) {\n    if (callback !== undefined) {\n      return this.unsubscribeByChannelAndCallback(callbackChannelToken, callback);\n    }\n    if (this.__isValidCallback(callbackChannelToken)) {\n      return this.unsubscribeByCallback(callbackChannelToken);\n    }\n    if (this.__isValidToken(callbackChannelToken)) {\n      return this.unsubscribeByToken(callbackChannelToken);\n    }\n    return 0;\n  }\n  /**\n   * @name unsubscribeByCallback\n   * @public\n   * @param {function} callback\n   * @returns {number}\n   */\n  unsubscribeByCallback(callback) {\n    this.__logging(\"unsubscribeByCallback\", { callback });\n    if (!this.__isValidCallback(callback)) {\n      return 0;\n    }\n    let deleted = 0;\n    this.__subscriptions.forEach((subscriptions) => {\n      objectKeys(subscriptions).forEach((key) => {\n        if (isSame(subscriptions[key].callback, callback)) {\n          delete subscriptions[key];\n          deleted += 1;\n        }\n      });\n    });\n    return deleted;\n  }\n  /**\n   * @name unsubscribeByChannelAndCallback\n   * @public\n   * @param {number|string|symbol} channel\n   * @param {function} callback\n   * @returns {number}\n   */\n  unsubscribeByChannelAndCallback(channel, callback) {\n    this.__logging(\"unsubscribeByChannelAndCallback\", { callback });\n    if (!this.hasSubscription(channel)) {\n      return 0;\n    }\n    const subscriptions = this.__subscriptions.get(channel);\n    let deleted = 0;\n    objectKeys(subscriptions).forEach((key) => {\n      if (isSame(subscriptions[key].callback, callback)) {\n        delete subscriptions[key];\n        deleted += 1;\n      }\n    });\n    return deleted;\n  }\n  /**\n   * @name unsubscribeByToken\n   * @public\n   * @param {string} token\n   * @returns {number}\n   */\n  unsubscribeByToken(token) {\n    this.__logging(\"unsubscribeByToken\", { token });\n    if (!this.__isValidToken(token)) {\n      return 0;\n    }\n    let deleted = 0;\n    this.__subscriptions.forEach((subscriptions) => {\n      if (token in subscriptions) {\n        delete subscriptions[token];\n        deleted += 1;\n      }\n    });\n    return deleted;\n  }\n}\n\nexport default PublishSubscribe;\n"],"names":["Subscription","[object Object]","channel","callback","once","this","token","generateToken","random","Array","index","Math","floor","join","getPrototypeName","value","Object","prototype","toString","call","args","PROTOTYPE_ASYNC","then","catch","PROTOTYPE_SYNC","_error","clone","val","typeOf","slice","assign","constructor","Number","Map","Set","cloneBuffer","len","length","buf","Buffer","allocUnsafe","from","copy","cloneSymbol","Symbol","valueOf","cloneArrayBuffer","res","byteLength","Uint8Array","set","cloneTypedArray","buffer","byteOffset","cloneRegExp","flags","exec","re","source","lastIndex","create","Boolean","String","Function","isArray","RegExp","Date","type","isBuffer","obj","isObjectObject","isObject","cloneDeep","instanceClone","cloneObjectDeep","isPlainObject","ctor","hasOwnProperty","key","cloneArrayDeep","isPrimitive","objectKeys","object","keys","isObjectEmpty","objectSize","isSame","variable1","variable2","is","newObject","PublishSubscribe","__channels","__onSubscribe","__onPublish","__subscriptions","__isValidCallback","isValidCallback","includes","bind","__isValidChannel","isValidChannel","isFinite","__isValidToken","isValidToken","__createChannel","createChannel","hasChannel","add","__createSubscription","createSubscription","subscription","get","disableLogging","dropAll","onPublish","__logging","__hasLogging","clear","delete","undefined","values","some","subscriptions","filter","sort","alpha","beta","localeCompare","has","data","cloneData","TypeError","sticky","getData","onSubscribe","promises","subscriptionReference","forEach","callbackReference","push","Promise","resolve","resultForPromise","promiseResult","result","error","all","resultOnly","results","map","curryCallback","method","info","publish","callbackChannelToken","unsubscribeByChannelAndCallback","unsubscribeByCallback","unsubscribeByToken","deleted","hasSubscription"],"mappings":"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"}