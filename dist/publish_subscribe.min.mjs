import n from"lodash.clonedeep";const s=()=>{},e="[object AsyncFunction]",t="[object Function]";function i(n,s){if(n)switch(h(n)){case e:n(...s).then(()=>{}).catch(()=>{});break;case t:try{n(...s)}catch(n){}}}function l(s){return function(n){return Object(n)!==n}(s)?s:n(s)}function h(n){return Object.prototype.toString.call(n)}function a(n){return 0===function(n){return r(n).length}(n)}function c(n,s){return Object.is(n,s)}function o(){return Object.create(null)}function r(n){return Object.keys(n)}class _{callback;channel;once;token;constructor(n,s,e=!1){this.callback=s,this.channel=n,this.once=e,this.token=function(){const n=new Array(16);for(let s=0;s<16;s+=1)n[s]="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"[Math.floor(62*Math.random())];return n.join("")}()}}class u{#channels=new Set;#createChannel;#createSubscription;#hasLogging;#isValidCallback;#isValidChannel;#isValidToken;#logging;#onPublish;#subscriptions=new Map;constructor(){this.#isValidCallback=function(n){return!!n&&[e,t].includes(h(n))}.bind(this),this.#isValidChannel=function(n){return"string"==typeof n||"symbol"==typeof n||"number"==typeof n&&Number.isFinite(n)}.bind(this),this.#isValidToken=function(n){return"string"==typeof n&&16===n.length}.bind(this),this.#createChannel=function(n){this.hasChannel(n)||(this.#channels.add(n),this.#subscriptions.set(n,o()))}.bind(this),this.#createSubscription=function(n,s,e){const t=new _(n,s,e);return this.#subscriptions.get(n)[t.token]=t,t.token}.bind(this),this.disableLogging(),this.dropAll(),this.onPublish()}disableLogging(){this.#logging=s,this.#hasLogging=!1}dropAll(){this.#logging("dropAll"),this.#channels.clear(),this.#subscriptions.clear()}dropChannel(n){this.#logging("dropChannel",{channel:n}),this.hasChannel(n)&&(this.#channels.delete(n),this.#subscriptions.set(n,o()))}getCallback(n){if(!this.#isValidToken(n))return;let s=void 0;return Array.from(this.#subscriptions.values()).some(e=>n in e&&(s=e[n].callback,!0)),s}getChannels(){return Array.from(this.#channels).filter(n=>"symbol"!=typeof n).sort((n,s)=>n.localeCompare(s))}hasChannel(n){return this.#channels.has(n)}hasSubscription(n){return!!this.hasChannel(n)&&(!!this.#subscriptions.has(n)&&!a(this.#subscriptions.get(n)))}onPublish(n){void 0!==n?this.#isValidCallback(n)&&(this.#onPublish=(s,e)=>{i(n,[s,e])}):this.#onPublish=s}publish(n,s,i=!0){let a;if(a=i?()=>l(s):()=>s,this.#logging("publish",{channel:n,data:a()}),this.#onPublish(n,a()),!this.hasChannel(n))return;const c=[],o=this.#subscriptions.get(n);r(o).forEach(s=>{const i=o[s],r=i.callback;switch(h(r)){case e:c.push(new Promise(e=>{let t;this.#hasLogging&&this.#logging("publish -> send",{channel:n,data:a(),token:s}),r(a(),n,s).then(h=>{t={channel:n,result:h,token:s},e(t),this.#hasLogging&&this.#logging("publish -> receive",{channel:n,result:l(h),token:s}),i.once&&delete o[s]}).catch(l=>{t={channel:n,result:l,token:s},e(t),this.#hasLogging&&this.#logging("publish -> receive",{channel:n,result:l,token:s}),i.once&&delete o[s]})}));break;case t:c.push(new Promise(e=>{let t;this.#hasLogging&&this.#logging("publish -> send",{channel:n,data:a(),token:s});try{t=r(a(),n,s)}catch(n){t=n}e({channel:n,result:t,token:s}),this.#hasLogging&&this.#logging("publish -> receive",{channel:n,result:l(t),token:s}),i.once&&delete o[s]}))}}),Promise.all(c).then(()=>{})}publishAsync(n,s,i=!0,a=!0){let c;if(c=a?()=>l(s):()=>s,this.#hasLogging&&this.#logging("publishAsync",{channel:n,data:c()}),this.#onPublish(n,c()),!this.hasChannel(n))return Promise.all([]);const o=[],_=this.#subscriptions.get(n);return r(_).forEach(s=>{const i=_[s],a=i.callback;switch(h(a)){case e:o.push(new Promise(e=>{let t;this.#hasLogging&&this.#logging("publishAsync -> send",{channel:n,data:c(),token:s}),a(c(),n,s).then(h=>{t={channel:n,result:h,token:s},e(t),this.#hasLogging&&this.#logging("publishAsync -> receive",{channel:n,result:l(h),token:s}),i.once&&delete _[s]}).catch(l=>{t={channel:n,result:l,token:s},e(t),this.#hasLogging&&this.#logging("publishAsync -> receive",{channel:n,result:l,token:s}),i.once&&delete _[s]})}));break;case t:o.push(new Promise(e=>{let t;this.#hasLogging&&this.#logging("publishAsync -> send",{channel:n,data:c(),token:s});try{t=a(c(),n,s)}catch(n){t=n}e({channel:n,result:t,token:s}),this.#hasLogging&&this.#logging("publishAsync -> receive",{channel:n,result:l(t),token:s}),i.once&&delete _[s]}))}}),i?Promise.all(o).then(n=>n.map(n=>n.result)):Promise.all(o)}publishSync(n,s,e=!0,a=!0,c){let o,_;if(o=a?()=>l(s):()=>s,this.#hasLogging&&this.#logging("publishSync",{channel:n,data:o()}),this.#onPublish(n,o()),_=c&&this.#isValidCallback(c)?n=>i(c,[n]):()=>{},!this.hasChannel(n))return _([]),[];const u=this.#subscriptions.get(n);let g=[];return r(u).forEach(s=>{const e=u[s],i=e.callback;if(h(i)!==t)return;let a;this.#hasLogging&&this.#logging("publishSync -> send",{channel:n,data:o(),token:s});try{a=i(o(),n,s)}catch(n){a=n}g.push({channel:n,result:a,token:s}),this.#hasLogging&&this.#logging("publishSync -> receive",{channel:n,result:l(a),token:s}),e.once&&delete u[s]}),e&&(g=g.map(n=>n.result)),_(g),g}setLogging(n){if(this.#isValidCallback(n))switch(h(n)){case e:this.#logging=(s,e)=>{n({...e,method:s}).then(()=>{}).catch(()=>{})},this.#hasLogging=!0;break;case t:this.#logging=(s,e)=>{try{n({...e,method:s})}catch(n){}},this.#hasLogging=!0}}subscribe(n,s,e=!1){return this.#logging("subscribe",{channel:n,callback:s,once:e}),this.#isValidChannel(n)?this.#isValidCallback(s)?(this.#createChannel(n),this.#createSubscription(n,s,e)):new TypeError("Callback should be a function."):new TypeError("Channel name should be String, Symbol, Number.")}subscribeOnce(n,s){return this.#logging("subscribeOnce",{channel:n,callback:s}),this.#isValidChannel(n)?this.#isValidCallback(s)?(this.#createChannel(n),this.#createSubscription(n,s)):new TypeError("Callback should be a function."):new TypeError("Channel name should be String, Symbol, Number.")}unsubscribe(n,s){return void 0!==s?this.unsubscribeByChannelAndCallback(n,s):this.#isValidCallback(n)?this.unsubscribeByCallback(n):this.#isValidToken(n)?this.unsubscribeByToken(n):0}unsubscribeByCallback(n){if(this.#logging("unsubscribeByCallback",{callback:n}),!this.#isValidCallback(n))return 0;let s=0;return this.#subscriptions.forEach(e=>{r(e).forEach(t=>{c(e[t].callback,n)&&(delete e[t],s+=1)})}),s}unsubscribeByChannelAndCallback(n,s){if(this.#logging("unsubscribeByChannelAndCallback",{callback:s}),!this.hasSubscription(n))return 0;const e=this.#subscriptions.get(n);let t=0;return r(e).forEach(n=>{c(e[n].callback,s)&&(delete e[n],t+=1)}),t}unsubscribeByToken(n){if(this.#logging("unsubscribeByToken",{token:n}),!this.#isValidToken(n))return 0;let s=0;return this.#subscriptions.forEach(e=>{n in e&&(delete e[n],s+=1)}),s}}export default u;export{u as PublishSubscribe};