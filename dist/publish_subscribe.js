var e,n;e=this,n=function(){const CALLBACK_STUB=()=>{},e="[object AsyncFunction]",n="[object Function]";function call(t,s){if(t)switch(getPrototypeName(t)){case e:t(...s).then(()=>{}).catch(()=>{});break;case n:try{t(...s)}catch(e){}}}function clone(e){return function isPrimitive(e){return Object(e)!==e}(e)?e:cloneDeep(e)}function getPrototypeName(e){return Object.prototype.toString.call(e)}function isObjectEmpty(e){return 0===function objectSize(e){return objectKeys(e).length}(e)}function isSame(e,n){return Object.is(e,n)}function newObject(){return Object.create(null)}function objectKeys(e){return Object.keys(e)}class Subscription{callback;channel;once;token;constructor(e,n,t=!1){this.callback=n,this.channel=e,this.once=t,this.token=function generateToken(){const e=new Array(16);for(let n=0;n<16;n+=1)e[n]="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"[Math.floor(62*Math.random())];return e.join("")}()}}return class PublishSubscribe{__channels=new Set;__createChannel;__createSubscription;__hasLogging;__isValidCallback;__isValidChannel;__isValidToken;__logging;__onPublish;__subscriptions=new Map;constructor(){this.__isValidCallback=function isValidCallback(t){return!!t&&[e,n].includes(getPrototypeName(t))}.bind(this),this.__isValidChannel=function isValidChannel(e){return"string"==typeof e||"symbol"==typeof e||"number"==typeof e&&Number.isFinite(e)}.bind(this),this.__isValidToken=function isValidToken(e){return"string"==typeof e&&16===e.length}.bind(this),this.__createChannel=function createChannel(e){this.hasChannel(e)||(this.__channels.add(e),this.__subscriptions.set(e,newObject()))}.bind(this),this.__createSubscription=function createSubscription(e,n,t){const s=new Subscription(e,n,t);return this.__subscriptions.get(e)[s.token]=s,s.token}.bind(this),this.disableLogging(),this.dropAll(),this.onPublish()}disableLogging(){this.__logging=CALLBACK_STUB,this.__hasLogging=!1}dropAll(){this.__logging("dropAll"),this.__channels.clear(),this.__subscriptions.clear()}dropChannel(e){this.__logging("dropChannel",{channel:e}),this.hasChannel(e)&&(this.__channels.delete(e),this.__subscriptions.set(e,newObject()))}getCallback(e){if(!this.__isValidToken(e))return;let n=void 0;return Array.from(this.__subscriptions.values()).some(t=>e in t&&(n=t[e].callback,!0)),n}getChannels(){return Array.from(this.__channels).filter(e=>"symbol"!=typeof e).sort((e,n)=>e.localeCompare(n))}hasChannel(e){return this.__channels.has(e)}hasSubscription(e){return!!this.hasChannel(e)&&!!this.__subscriptions.has(e)&&!isObjectEmpty(this.__subscriptions.get(e))}onPublish(e){void 0!==e?this.__isValidCallback(e)&&(this.__onPublish=(n,t)=>{call(e,[n,t])}):this.__onPublish=CALLBACK_STUB}publish(t,s,i=!0){let l;if(l=i?()=>clone(s):()=>s,this.__logging("publish",{channel:t,data:l()}),this.__onPublish(t,l()),!this.hasChannel(t))return;const c=[],a=this.__subscriptions.get(t);objectKeys(a).forEach(s=>{const i=a[s],h=i.callback;switch(getPrototypeName(h)){case e:c.push(new Promise(e=>{let n;this.__hasLogging&&this.__logging("publish -> send",{channel:t,data:l(),token:s}),h(l(),t,s).then(l=>{n={channel:t,result:l,token:s},e(n),this.__hasLogging&&this.__logging("publish -> receive",{channel:t,result:clone(l),token:s}),i.once&&delete a[s]}).catch(l=>{n={channel:t,result:l,token:s},e(n),this.__hasLogging&&this.__logging("publish -> receive",{channel:t,result:l,token:s}),i.once&&delete a[s]})}));break;case n:c.push(new Promise(e=>{let n;this.__hasLogging&&this.__logging("publish -> send",{channel:t,data:l(),token:s});try{n=h(l(),t,s)}catch(e){n=e}e({channel:t,result:n,token:s}),this.__hasLogging&&this.__logging("publish -> receive",{channel:t,result:clone(n),token:s}),i.once&&delete a[s]}))}}),Promise.all(c).then(()=>{})}publishAsync(t,s,i=!0,l=!0){let c;if(c=l?()=>clone(s):()=>s,this.__hasLogging&&this.__logging("publishAsync",{channel:t,data:c()}),this.__onPublish(t,c()),!this.hasChannel(t))return Promise.all([]);const a=[],h=this.__subscriptions.get(t);return objectKeys(h).forEach(s=>{const i=h[s],l=i.callback;switch(getPrototypeName(l)){case e:a.push(new Promise(e=>{let n;this.__hasLogging&&this.__logging("publishAsync -> send",{channel:t,data:c(),token:s}),l(c(),t,s).then(l=>{n={channel:t,result:l,token:s},e(n),this.__hasLogging&&this.__logging("publishAsync -> receive",{channel:t,result:clone(l),token:s}),i.once&&delete h[s]}).catch(l=>{n={channel:t,result:l,token:s},e(n),this.__hasLogging&&this.__logging("publishAsync -> receive",{channel:t,result:l,token:s}),i.once&&delete h[s]})}));break;case n:a.push(new Promise(e=>{let n;this.__hasLogging&&this.__logging("publishAsync -> send",{channel:t,data:c(),token:s});try{n=l(c(),t,s)}catch(e){n=e}e({channel:t,result:n,token:s}),this.__hasLogging&&this.__logging("publishAsync -> receive",{channel:t,result:clone(n),token:s}),i.once&&delete h[s]}))}}),i?Promise.all(a).then(e=>e.map(e=>e.result)):Promise.all(a)}publishSync(e,t,s=!0,i=!0,l){let c,a;if(c=i?()=>clone(t):()=>t,this.__hasLogging&&this.__logging("publishSync",{channel:e,data:c()}),this.__onPublish(e,c()),a=l&&this.__isValidCallback(l)?e=>call(l,[e]):()=>{},!this.hasChannel(e))return a([]),[];const h=this.__subscriptions.get(e);let o=[];return objectKeys(h).forEach(t=>{const s=h[t],i=s.callback;if(getPrototypeName(i)!==n)return;let l;this.__hasLogging&&this.__logging("publishSync -> send",{channel:e,data:c(),token:t});try{l=i(c(),e,t)}catch(e){l=e}o.push({channel:e,result:l,token:t}),this.__hasLogging&&this.__logging("publishSync -> receive",{channel:e,result:clone(l),token:t}),s.once&&delete h[t]}),s&&(o=o.map(e=>e.result)),a(o),o}setLogging(t){if(this.__isValidCallback(t))switch(getPrototypeName(t)){case e:this.__logging=(e,n)=>{t({...n,method:e}).then(()=>{}).catch(()=>{})},this.__hasLogging=!0;break;case n:this.__logging=(e,n)=>{try{t({...n,method:e})}catch(e){}},this.__hasLogging=!0}}subscribe(e,n,t=!1){return this.__logging("subscribe",{channel:e,callback:n,once:t}),this.__isValidChannel(e)?this.__isValidCallback(n)?(this.__createChannel(e),this.__createSubscription(e,n,t)):new TypeError("Callback should be a function."):new TypeError("Channel name should be String, Symbol, Number.")}subscribeOnce(e,n){return this.__logging("subscribeOnce",{channel:e,callback:n}),this.__isValidChannel(e)?this.__isValidCallback(n)?(this.__createChannel(e),this.__createSubscription(e,n)):new TypeError("Callback should be a function."):new TypeError("Channel name should be String, Symbol, Number.")}unsubscribe(e,n){return void 0!==n?this.unsubscribeByChannelAndCallback(e,n):this.__isValidCallback(e)?this.unsubscribeByCallback(e):this.__isValidToken(e)?this.unsubscribeByToken(e):0}unsubscribeByCallback(e){if(this.__logging("unsubscribeByCallback",{callback:e}),!this.__isValidCallback(e))return 0;let n=0;return this.__subscriptions.forEach(t=>{objectKeys(t).forEach(s=>{isSame(t[s].callback,e)&&(delete t[s],n+=1)})}),n}unsubscribeByChannelAndCallback(e,n){if(this.__logging("unsubscribeByChannelAndCallback",{callback:n}),!this.hasSubscription(e))return 0;const t=this.__subscriptions.get(e);let s=0;return objectKeys(t).forEach(e=>{isSame(t[e].callback,n)&&(delete t[e],s+=1)}),s}unsubscribeByToken(e){if(this.__logging("unsubscribeByToken",{token:e}),!this.__isValidToken(e))return 0;let n=0;return this.__subscriptions.forEach(t=>{e in t&&(delete t[e],n+=1)}),n}}},"function"==typeof define&&define.amd?define((function(){return e.PublishSubscribe=n()})):"object"==typeof exports||"object"==typeof module&&module.exports?module.exports=e.PublishSubscribe=n():e.PublishSubscribe=n();